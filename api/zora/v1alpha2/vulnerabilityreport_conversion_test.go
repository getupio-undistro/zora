// Copyright 2024 Undistro Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package v1alpha2

import (
	"reflect"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/undistro/zora/api/zora/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/utils/pointer"
)

var (
	now  = metav1.Now()
	meta = metav1.ObjectMeta{
		Name:              "v1a2report",
		Namespace:         "namespace",
		UID:               "v1a2report-uid",
		ResourceVersion:   "123",
		Generation:        1,
		CreationTimestamp: now,
		Labels:            map[string]string{"foo": "bar"},
		Annotations:       map[string]string{"bar": "foo"},
		OwnerReferences: []metav1.OwnerReference{{
			APIVersion:         "v1",
			Kind:               "Owner",
			Name:               "owner",
			UID:                "owner-uid",
			Controller:         pointer.Bool(true),
			BlockOwnerDeletion: pointer.Bool(true),
		}},
	}
	vulnCommon = v1alpha1.VulnerabilityCommon{
		ID:          "CVE-2022-4450",
		Severity:    "HIGH",
		Title:       "double free after calling PEM_read_bio_ex",
		Description: "The function PEM_read_bio_ex() reads a PEM file from a BIO and ...",
		URL:         "https://avd.aquasec.com/nvd/cve-2022-4450",
		Score:       "7.5",
	}
	status = v1alpha1.Status{
		ObservedGeneration: 1,
		Conditions: []metav1.Condition{{
			Type:               "Ready",
			Status:             "True",
			ObservedGeneration: 1,
			LastTransitionTime: now,
			Reason:             "reason",
			Message:            "message",
		}},
	}
)

func TestVulnerabilityReportConversion(t *testing.T) {
	tests := []struct {
		v1a2    *VulnerabilityReport
		wantErr bool
		v1a1    *v1alpha1.VulnerabilityReport
	}{
		{
			v1a2: &VulnerabilityReport{
				ObjectMeta: meta,
				Spec: VulnerabilityReportSpec{
					VulnerabilityReportCommon: newVulnerabilityReportCommon(v1alpha1.VulnerabilitySummary{Total: 1, High: 1}),
					TotalPackages:             2,
					TotalUniquePackages:       2,
					Vulnerabilities: []Vulnerability{{
						VulnerabilityCommon: vulnCommon,
						Packages: []v1alpha1.Package{
							{
								FixVersion: "1.1.1t-r0",
								Package:    "libcrypto1.1",
								Status:     "fixed",
								Type:       "alpine",
								Version:    "1.1.1s-r0",
							},
							{
								FixVersion: "1.1.1t-r0",
								Package:    "libssl1.1",
								Status:     "fixed",
								Type:       "alpine",
								Version:    "1.1.1s-r0",
							},
						},
					}},
				},
				Status: VulnerabilityReportStatus{Status: status},
			},
			wantErr: false,
			v1a1: &v1alpha1.VulnerabilityReport{
				ObjectMeta: meta,
				Spec: v1alpha1.VulnerabilityReportSpec{
					VulnerabilityReportCommon: newVulnerabilityReportCommon(v1alpha1.VulnerabilitySummary{Total: 2, High: 2}),
					Vulnerabilities: []v1alpha1.Vulnerability{
						{
							VulnerabilityCommon: vulnCommon,
							Package: v1alpha1.Package{
								FixVersion: "1.1.1t-r0",
								Package:    "libcrypto1.1",
								Status:     "fixed",
								Type:       "alpine",
								Version:    "1.1.1s-r0",
							},
						},
						{
							VulnerabilityCommon: vulnCommon,
							Package: v1alpha1.Package{
								FixVersion: "1.1.1t-r0",
								Package:    "libssl1.1",
								Status:     "fixed",
								Type:       "alpine",
								Version:    "1.1.1s-r0",
							},
						},
					},
				},
				Status: v1alpha1.VulnerabilityReportStatus{Status: status},
			},
		},
	}
	for _, tt := range tests {
		t.Run("ConvertTo", func(t *testing.T) {
			got := &v1alpha1.VulnerabilityReport{}
			if err := tt.v1a2.ConvertTo(got); (err != nil) != tt.wantErr {
				t.Errorf("ConvertTo() error = %v, wantErr %v", err, tt.wantErr)
			}
			if !reflect.DeepEqual(got, tt.v1a1) {
				t.Errorf("ConvertTo() mismatch (-want +got):\n%s", cmp.Diff(tt.v1a1, got))
			}
		})
		t.Run("ConvertFrom", func(t *testing.T) {
			got := &VulnerabilityReport{}
			if err := got.ConvertFrom(tt.v1a1); (err != nil) != tt.wantErr {
				t.Errorf("ConvertFrom() error = %v, wantErr %v", err, tt.wantErr)
			}
			if !reflect.DeepEqual(tt.v1a2, got) {
				t.Errorf("ConvertFrom() mismatch (-want +got):\n%s", cmp.Diff(tt.v1a2, got))
			}
		})
	}
}

func newVulnerabilityReportCommon(summary v1alpha1.VulnerabilitySummary) v1alpha1.VulnerabilityReportCommon {
	return v1alpha1.VulnerabilityReportCommon{
		Cluster:        "cluster",
		Image:          "image:tag",
		Digest:         "image@sha254:uuid",
		Tags:           []string{"image:tag"},
		Architecture:   "amd64",
		OS:             "linux",
		Distro:         &v1alpha1.Distro{Name: "alpine", Version: "3.16.3"},
		TotalResources: 1,
		Resources:      map[string][]string{"Deployment": {"foo/bar"}},
		Summary:        summary,
	}
}
